// 1 CorrectAnswer, 1 WrongAnswer, 1 RuntimeError
{
    "ExecutionType": "tests-execution",
    "ExecutionStrategy": "cpp-zip-file",
    "CompilerType": "CPlusPlusZip",
    "FileContent": "UEsDBBQAAAAIABZa+VbjtqAoJwMAAHYJAAAJAAAAU25ha2UuY3BwjVVtT+JAEP4sCf9hzksuEJH4ubwkRtQjKhAQ/UhKu8jG2uV2t3A5cvfbb3a33e0LIkZjOzvzzMzTZ2a/0ziIkpDA+Sz230l7fV6vWVuXMiE58T/69Vq9JqQvaQATRmMJb0TeJZJwMmGiEbBYSBhQTgJJWQwh5S3QRuP9AzZMNGFfr52Z6FUiEx0KPXXUwQOxozJYNzC0qfwCXxCH6HnT4f3PZw8Pzi4ubHQ7YFFH2ZZY5HvnQNhg/DqqRHG2Ox41n+iYy8sjMSFZ+UkkPVBWIUPPCwjn0O3C+ZQEdEtCoPHWj2gIJE4+AB8T4sG58jBMLjCt7CIdfd21OtA4JA5LXf3FP06wlNgxh3Y0577LkrEIqHhiW/Ki0jbKH6AFmnpKonDKdviKqFD5cU43LBLwmZcGN/VukTbGuzpR/wewJRYURES06jXleTw4JL8SYmOF0uCIhSRVC11B4wqgDxvzCYzVcuFHgqT8ZM7K1wjjS9/UD/o91+9JQVgIBlkmjwSd4e+Kcch/C8cQePYxxdAp7HGv5+amCo/4R3LELER8S2ghAZ6dCu6EJ3lCOpCKTmtNrFkShRO2I3y+qaoNQ0/WzMaAfCIZQf+QBaKuWBKHw/A3mKqNGSgaenDVOUCDBQYve8rzkJpKVNgsPQWtychxkLJjVoo5V29FAlOW9Eb1PP3PlFWeQGt0CiwtTpQClxNVnd40i7vh7eNgMR2/zho5/bUgPbgZP+KBVTPag4RztaMt0F7BOF20N4lYL5Z+8O5cSg38Mx0098aI6yYRN0pD6fkHrpyDd8BJW+LggjkUU/yERvgmQeVSKV5PWEpKhG4uC8s2pt6WGKO+aX5/WjwMdrQXqIZWvhHHqs6iNfYth1jcE5ZHJZHR9cPtYnB7PcgtjhzRgZ7YYsjz9fN8tpiPHkZ4x3XsPJgpoUMzFaVmreJLw+tadaPogGwz6VnaR1pUtY975Gk4uteTksG1CcdLtmFfl+SNxo0mXOTSZL0TnKEvUjyNX9IMRS2zjZFyhlVV+oqzWLqGtWOmDUyVv1/dWGMddqqr11Y2Byi6mc2Gve0dQK4MhfMfUEsBAj8AFAAAAAgAFlr5VuO2oCgnAwAAdgkAAAkAJAAAAAAAAAAgAAAAAAAAAFNuYWtlLmNwcAoAIAAAAAAAAQAYAJNiWljQvtkBAAAAAAAAAAAAAAAAAAAAAFBLBQYAAAAAAQABAFsAAABOAwAAAAA\u003d",
    "Code": "",
    "TimeLimit": 500,
    "MemoryLimit": 16777216,
    "ExecutionDetails": {
      "MaxPoints": 100,
      "CheckerType": "trim",
      "CheckerParameter": null,
      "Tests": [
        {
            "Id": 221675,
            "Input": "3 3 1 1\n0\n0\n2\n0 0\n0 0\n\n",
            "Output": "Printing initial Field state:\r\n...\r\n.@.\r\n...\r\n\r\nMOVE_SNAKE in dir: UP, status: SNAKE_MOVING\r\nPrinting Field:\r\n.@.\r\n...\r\n...\r\n\r\nMOVE_SNAKE in dir: UP, status: SNAKE_DEAD\r\n\r\n",
            "IsTrialTest": true,
            "OrderBy": 1
          },
        {
          "Id": 221678,
          "Input": "2 2 1 1\r\n0\r\n0\r\n2\r\n0 0\r\n0 3\r\n\r\n",
          "Output": "Printing initial Field state:\r\n..\r\n.@\r\n\r\nMOVE_SNAKE in dir: UP, status: SNAKE_MOVING\r\nPrinting Field:\r\n.@\r\n..\r\n\r\nMOVE_SNAKE in dir: LEFT, status: SNAKE_MOVING\r\nPrinting Field:\r\n@.\r\n..\r\n\r\n",
          "IsTrialTest": false,
          "OrderBy": 1
        },
        {
          "Id": 221685,
          "Input": "4 4 0 0\r\n2\r\n1 1\r\n0 1\r\n3\r\n1 0\r\n2 0\r\n2 1\r\n5\r\n0 2\r\n0 2\r\n0 1\r\n0 1\r\n0 0\r\n\r\n",
          "Output": "Printing initial Field state:\r\n@o..\r\n*o..\r\n**..\r\n....\r\n\r\nMOVE_SNAKE in dir: DOWN, status: SNAKE_GROWING\r\nPrinting Field:\r\nxo..\r\n@o..\r\n**..\r\n....\r\n\r\nMOVE_SNAKE in dir: DOWN, status: SNAKE_GROWING\r\nPrinting Field:\r\nxo..\r\nxo..\r\n@*..\r\n....\r\n\r\nMOVE_SNAKE in dir: RIGHT, status: SNAKE_GROWING\r\nPrinting Field:\r\nxo..\r\nxo..\r\nx@..\r\n....\r\n\r\nMOVE_SNAKE in dir: RIGHT, status: SNAKE_MOVING\r\nPrinting Field:\r\n.o..\r\nxo..\r\nxx@.\r\n....\r\n\r\nMOVE_SNAKE in dir: UP, status: SNAKE_MOVING\r\nPrinting Field:\r\n.o..\r\n.o@.\r\nxxx.\r\n....\r\n\r\n",
          "IsTrialTest": false,
          "OrderBy": 8
        }
      ],
      "TaskSkeleton": "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",
      "TaskSkeletonAsString": "//Defines.h//\r\n#ifndef DEFINES_H_\r\n#define DEFINES_H_\r\n\r\nenum InputCommands\r\n{\r\n    MOVE_SNAKE        \u003d 0,\r\n    GENERATE_OBSTACLE \u003d 1,\r\n    GENERATE_POWER_UP \u003d 2\r\n};\r\n\r\nenum FieldMarkerDefines\r\n{\r\n    EMPTY_FIELD_MARKER \u003d \u0027.\u0027,\r\n    OBSTACLE_MARKER    \u003d \u0027o\u0027,\r\n    POWER_UP_MARKER    \u003d \u0027*\u0027,\r\n    SNAKE_HEAD_MARKER  \u003d \u0027@\u0027,\r\n    SNAKE_BODY_MARKER  \u003d \u0027x\u0027\r\n};\r\n\r\nenum class Direction\r\n{\r\n    UP    \u003d 0,\r\n    RIGHT \u003d 1,\r\n    DOWN  \u003d 2,\r\n    LEFT  \u003d 3\r\n};\r\n\r\nenum class StatusCode\r\n{\r\n    SNAKE_MOVING   \u003d 0,\r\n    SNAKE_GROWING  \u003d 1,\r\n    SNAKE_DEAD     \u003d 2,\r\n\r\n    STATUS_UNKNOWN \u003d 255\r\n};\r\n\r\nenum GeneralDefines\r\n{\r\n    DIRECTIONS_COUNT \u003d 4\r\n};\r\n\r\n\r\n#endif /* DEFINES_H_ */\r\n~~!!!\u003d\u003d#\u003d\u003d!!!~~\r\n//Structs.h//\r\n#ifndef STRUCTS_H_\r\n#define STRUCTS_H_\r\n\r\n#include \u003cvector\u003e\r\n\r\nstruct Point\r\n{\r\n    Point(const int inputRow,\r\n          const int inputCol) : row(inputRow),\r\n                                col(inputCol)\r\n    {\r\n\r\n    }\r\n\r\n    Point() : row(0), col(0)\r\n    {\r\n\r\n    }\r\n\r\n    bool operator\u003d\u003d(const Point \u0026 other) const\r\n    {\r\n        return (row \u003d\u003d other.row) \u0026\u0026 (col \u003d\u003d other.col);\r\n    }\r\n\r\n    bool operator!\u003d(const Point \u0026 other) const\r\n    {\r\n        return !operator\u003d\u003d(other);\r\n    }\r\n\r\n    int row;\r\n    int col;\r\n};\r\n\r\nstruct FieldConfig\r\n{\r\n    FieldConfig(const int                  inputRowsCount,\r\n                const int                  inputColsCount,\r\n                const Point \u0026              inputSnakeStartPos,\r\n                const std::vector\u003cPoint\u003e \u0026 inputObstacles,\r\n                const std::vector\u003cPoint\u003e \u0026 inputPowerUps) :\r\n                                              rowsCount(inputRowsCount),\r\n                                              colsCount(inputColsCount),\r\n                                              snakeStartPos(inputSnakeStartPos),\r\n                                              obstacles(inputObstacles),\r\n                                              powerUps(inputPowerUps)\r\n    {\r\n\r\n    }\r\n\r\n    int                rowsCount;\r\n    int                colsCount;\r\n    const Point              snakeStartPos;\r\n    const std::vector\u003cPoint\u003e obstacles;\r\n    const std::vector\u003cPoint\u003e powerUps;\r\n};\r\n\r\n#endif /* STRUCTS_H_ */\r\n~~!!!\u003d\u003d#\u003d\u003d!!!~~\r\n//Snake.h//\r\n#ifndef SNAKE_H_\r\n#define SNAKE_H_\r\n\r\n#include \"Structs.h\"\r\n#include \"Defines.h\"\r\n\r\n#include \u003cdeque\u003e\r\n\r\nclass Snake\r\n{\r\n    public:\r\n        Snake(const int     fieldRows,\r\n              const int     fieldCols,\r\n              const Point \u0026 startPos);\r\n\r\n        ~Snake();\r\n\r\n        StatusCode move(const Direction            dir,\r\n                        const std::vector\u003cPoint\u003e \u0026 obstacles,\r\n                        std::vector\u003cPoint\u003e \u0026       powerUps);\r\n\r\n        std::deque\u003cPoint\u003e \u0026 getSnakeNodes();\r\n\r\n    private:\r\n        int         _FIELD_ROWS;\r\n        int         _FIELD_COLS;\r\n\r\n        Point             _currPos;\r\n\r\n        //std::deque\u003c\u003e has same API as std::vector\u003c\u003e\r\n        //with some additional functionalities\r\n        std::deque\u003cPoint\u003e _snakeNodes; //holds snake head + body nodes\r\n};\r\n\r\n#endif /* SNAKE_H_ */\r\n~~!!!\u003d\u003d#\u003d\u003d!!!~~\r\n//Field.h//\r\n#ifndef FIELD_H_\r\n#define FIELD_H_\r\n\r\n#include \u003cstring\u003e\r\n\r\n#include \"Structs.h\"\r\n#include \"Snake.h\"\r\n\r\nclass Field\r\n{\r\n    public:\r\n        Field(const FieldConfig \u0026 cfg);\r\n\r\n        ~Field() \u003d default;\r\n\r\n        void generatePowerUp(const Point \u0026 pos);\r\n\r\n        void generateObstacle(const Point \u0026 pos);\r\n\r\n        StatusCode moveSnake(const Direction dir);\r\n\r\n        void printField(const bool isInitialPrint \u003d false) const;\r\n\r\n    private:\r\n        void updateFieldState();\r\n\r\n        const int                _ROWS;\r\n        const int                _COLS;\r\n\r\n        std::vector\u003cPoint\u003e       _obstacles;\r\n        std::vector\u003cPoint\u003e       _powerUps;\r\n\r\n        std::vector\u003cstd::string\u003e _fieldNodes;\r\n\r\n        Snake                    _snake;\r\n};\r\n\r\n#endif /* FIELD_H_ */\r\n~~!!!\u003d\u003d#\u003d\u003d!!!~~\r\n//Field.cpp//\r\n#include \"Field.h\"\r\n\r\n#include \u003ciostream\u003e\r\n\r\nField::Field(const FieldConfig \u0026 cfg) : _ROWS(cfg.rowsCount),\r\n                                        _COLS(cfg.colsCount),\r\n                                        _obstacles(cfg.obstacles),\r\n                                        _powerUps(cfg.powerUps),\r\n                                        _fieldNodes(_ROWS),\r\n                                        _snake(cfg.rowsCount,\r\n                                               cfg.colsCount,\r\n                                               cfg.snakeStartPos)\r\n{\r\n    updateFieldState();\r\n    printField(true);\r\n}\r\n\r\nvoid Field::generatePowerUp(const Point \u0026 pos)\r\n{\r\n    _powerUps.emplace_back(pos);\r\n    _fieldNodes[pos.row][pos.col] \u003d POWER_UP_MARKER;\r\n}\r\n\r\nvoid Field::generateObstacle(const Point \u0026 pos)\r\n{\r\n    _obstacles.emplace_back(pos);\r\n    _fieldNodes[pos.row][pos.col] \u003d OBSTACLE_MARKER;\r\n}\r\n\r\nStatusCode Field::moveSnake(const Direction dir)\r\n{\r\n    const StatusCode STATUS_CODE \u003d _snake.move(dir, _obstacles, _powerUps);\r\n\r\n    if(StatusCode::SNAKE_DEAD !\u003d STATUS_CODE)\r\n    {\r\n        updateFieldState();\r\n    }\r\n\r\n    return STATUS_CODE;\r\n}\r\n\r\nvoid Field::printField(const bool isInitialPrint) const\r\n{\r\n    std::cout \u003c\u003c (isInitialPrint ?\r\n            \"Printing initial Field state:\\n\" : \"Printing Field:\\n\");\r\n\r\n    for(const std::string \u0026 row : _fieldNodes)\r\n    {\r\n        std::cout \u003c\u003c row \u003c\u003c \u0027\\n\u0027;\r\n    }\r\n    std::cout \u003c\u003c \u0027\\n\u0027;\r\n}\r\n\r\nvoid Field::updateFieldState()\r\n{\r\n    //reset field\r\n    for(std::string \u0026 row : _fieldNodes)\r\n    {\r\n        row \u003d std::string(_COLS, EMPTY_FIELD_MARKER);\r\n    }\r\n\r\n    //apply obstacles\r\n    for(const Point \u0026 obstacle : _obstacles)\r\n    {\r\n        _fieldNodes[obstacle.row][obstacle.col] \u003d OBSTACLE_MARKER;\r\n    }\r\n\r\n    //apply power ups\r\n    for(const Point \u0026 powerUp : _powerUps)\r\n    {\r\n        _fieldNodes[powerUp.row][powerUp.col] \u003d POWER_UP_MARKER;\r\n    }\r\n\r\n    //apply snake nodes\r\n    const std::deque\u003cPoint\u003e \u0026 SNAKE_NODES \u003d _snake.getSnakeNodes();\r\n    const size_t SNAKE_SIZE \u003d SNAKE_NODES.size();\r\n    const Point \u0026 SNAKE_HEAD \u003d SNAKE_NODES.front();\r\n\r\n    _fieldNodes[SNAKE_HEAD.row][SNAKE_HEAD.col] \u003d SNAKE_HEAD_MARKER;\r\n\r\n    for(size_t i \u003d 1; i \u003c SNAKE_SIZE; ++i)\r\n    {\r\n        _fieldNodes[SNAKE_NODES[i].row][SNAKE_NODES[i].col] \u003d SNAKE_BODY_MARKER;\r\n    }\r\n}\r\n\r\n\r\n\r\n~~!!!\u003d\u003d#\u003d\u003d!!!~~\r\n//CommandExecutor.h//\r\n#ifndef COMMANDEXECUTOR_H_\r\n#define COMMANDEXECUTOR_H_\r\n\r\n#include \u003cstring\u003e\r\n\r\n#include \"Field.h\"\r\n\r\nclass CommandExecutor\r\n{\r\n\tpublic:\r\n\t\tCommandExecutor(const FieldConfig \u0026 cfg);\r\n\t\t~CommandExecutor() \u003d default;\r\n\r\n\t\tvoid extractCommand(const std::string \u0026 commandStr);\r\n\r\n\t\tbool isGameActive() const;\r\n\r\n\tprivate:\r\n        void executeMoveSnake(const int moveDirectionId);\r\n\r\n\t\tvoid executeGenerateObstacle(const Point \u0026 pos);\r\n\r\n        void executeGeneratePowerUp(const Point \u0026 pos);\r\n\r\n\t\tField _field;\r\n\r\n\t\tbool  _isGameActive;\r\n};\r\n\r\n#endif /* COMMANDEXECUTOR_H_ */\r\n~~!!!\u003d\u003d#\u003d\u003d!!!~~\r\n//CommandExecutor.cpp//\r\n#include \"CommandExecutor.h\"\r\n#include \"Defines.h\"\r\n\r\n#include \u003csstream\u003e\r\n#include \u003ciostream\u003e\r\n\r\nstatic const char * DIR_STRINGS[DIRECTIONS_COUNT]\r\n{\r\n    \"UP\",\r\n    \"RIGHT\",\r\n    \"DOWN\",\r\n    \"LEFT\"\r\n};\r\n\r\nCommandExecutor::CommandExecutor(const FieldConfig \u0026 cfg) : _field(cfg),\r\n                                                            _isGameActive(true)\r\n{\r\n\r\n}\r\n\r\nvoid CommandExecutor::extractCommand(const std::string \u0026 commandStr)\r\n{\r\n\tstd::istringstream istr(commandStr);\r\n\tint currCommand \u003d 0;\r\n\tistr \u003e\u003e currCommand;\r\n\r\n\tswitch(currCommand)\r\n\t{\r\n\t\tcase InputCommands::MOVE_SNAKE:\r\n\t\t{\r\n\t\t\tint moveDirectionId \u003d 0;\r\n\t\t\tistr \u003e\u003e moveDirectionId;\r\n\r\n\t\t\texecuteMoveSnake(moveDirectionId);\r\n\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase InputCommands::GENERATE_OBSTACLE:\r\n        {\r\n            Point obstaclePos;\r\n            istr \u003e\u003e obstaclePos.row \u003e\u003e obstaclePos.col;\r\n\r\n            executeGenerateObstacle(obstaclePos);\r\n        }\r\n\t\t\tbreak;\r\n\r\n\t\tcase InputCommands::GENERATE_POWER_UP:\r\n        {\r\n            Point powerUpPos;\r\n            istr \u003e\u003e powerUpPos.row \u003e\u003e powerUpPos.col;\r\n\r\n            executeGeneratePowerUp(powerUpPos);\r\n        }\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t    std::cerr \u003c\u003c \"Warning, received unknown InputCommand: \"\r\n\t\t              \u003c\u003c currCommand \u003c\u003c std::endl;\r\n\t\t    break;\r\n\t}\r\n}\r\n\r\nbool CommandExecutor::isGameActive() const\r\n{\r\n    return _isGameActive;\r\n}\r\n\r\nvoid CommandExecutor::executeMoveSnake(const int moveDirectionId)\r\n{\r\n    std::cout \u003c\u003c \"MOVE_SNAKE in dir: \"\r\n              \u003c\u003c DIR_STRINGS[moveDirectionId] \u003c\u003c \", status: \";\r\n\r\n    const StatusCode STATUS_CODE \u003d\r\n                    _field.moveSnake(static_cast\u003cDirection\u003e(moveDirectionId));\r\n\r\n    switch(STATUS_CODE)\r\n    {\r\n        case StatusCode::SNAKE_MOVING:\r\n            std::cout \u003c\u003c \"SNAKE_MOVING\\n\";\r\n            break;\r\n\r\n        case StatusCode::SNAKE_GROWING:\r\n            std::cout \u003c\u003c \"SNAKE_GROWING\\n\";\r\n            break;\r\n\r\n        case StatusCode::SNAKE_DEAD:\r\n            std::cout \u003c\u003c \"SNAKE_DEAD\\n\";\r\n            _isGameActive \u003d false;\r\n            break;\r\n\r\n        default:\r\n            std::cout \u003c\u003c \"ERROR\\n\";\r\n            break;\r\n    }\r\n\r\n    if(StatusCode::SNAKE_DEAD !\u003d STATUS_CODE)\r\n    {\r\n        _field.printField();\r\n    }\r\n}\r\n\r\nvoid CommandExecutor::executeGenerateObstacle(const Point \u0026 pos)\r\n{\r\n    std::cout \u003c\u003c \"GENERATE_OBSTACLE at row: \" \u003c\u003c pos.row\r\n              \u003c\u003c \", col: \" \u003c\u003c pos.col \u003c\u003c \u0027\\n\u0027;\r\n\r\n    _field.generateObstacle(pos);\r\n    _field.printField();\r\n}\r\n\r\nvoid CommandExecutor::executeGeneratePowerUp(const Point \u0026 pos)\r\n{\r\n    std::cout \u003c\u003c \"GENERATE_POWER_UP at row: \" \u003c\u003c pos.row\r\n              \u003c\u003c \", col: \" \u003c\u003c pos.col \u003c\u003c \u0027\\n\u0027;\r\n\r\n    _field.generatePowerUp(pos);\r\n    _field.printField();\r\n}\r\n\r\n\r\n\r\n\r\n~~!!!\u003d\u003d#\u003d\u003d!!!~~\r\n//main.cpp//\r\n#include \u003ciostream\u003e\r\n#include \u003cstring\u003e\r\n\r\n#include \"CommandExecutor.h\"\r\n\r\n//Enable RVO (Return value optimization)\r\nstatic FieldConfig parseFieldConfig()\r\n{\r\n    int fieldRows      \u003d 0;\r\n    int fieldCols      \u003d 0;\r\n    int obstaclesCount \u003d 0;\r\n    int powerUpsCount  \u003d 0;\r\n\r\n    int currRow \u003d 0;\r\n    int currCol \u003d 0;\r\n\r\n    std::vector\u003cPoint\u003e obstacles;\r\n    std::vector\u003cPoint\u003e powerUps;\r\n    Point              snakeStartPos;\r\n\r\n    std::cin \u003e\u003e fieldRows \u003e\u003e fieldCols\r\n             \u003e\u003e snakeStartPos.row \u003e\u003e snakeStartPos.col;\r\n\r\n    std::cin \u003e\u003e obstaclesCount;\r\n    obstacles.reserve(obstaclesCount);\r\n\r\n    for(int i \u003d 0; i \u003c obstaclesCount; ++i)\r\n    {\r\n        std::cin \u003e\u003e currRow \u003e\u003e currCol;\r\n        obstacles.emplace_back(currRow, currCol);\r\n    }\r\n\r\n    std::cin \u003e\u003e powerUpsCount;\r\n    powerUps.reserve(powerUpsCount);\r\n\r\n    for(int i \u003d 0; i \u003c powerUpsCount; ++i)\r\n    {\r\n        std::cin \u003e\u003e currRow \u003e\u003e currCol;\r\n        powerUps.emplace_back(currRow, currCol);\r\n    }\r\n\r\n    return FieldConfig(fieldRows,\r\n                       fieldCols,\r\n                       snakeStartPos,\r\n                       obstacles,\r\n                       powerUps);\r\n}\r\n\r\nint main()\r\n{\r\n    CommandExecutor commandExecutor(parseFieldConfig());\r\n\r\n    int commands \u003d 0;\r\n    std::string input;\r\n\r\n    std::cin \u003e\u003e commands;\r\n    std::cin.ignore();\r\n\r\n    for(int i \u003d 0; i \u003c commands; ++i)\r\n    {\r\n        getline(std::cin, input);\r\n\r\n        if(commandExecutor.isGameActive())\r\n        {\r\n            commandExecutor.extractCommand(input);\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}"
    },
    "ExecutionOptions": {
      "KeepDetails": true,
      "EscapeTests": false,
      "EscapeLineEndings": true
    },
    "WithExceptionStackTrace": true
  }