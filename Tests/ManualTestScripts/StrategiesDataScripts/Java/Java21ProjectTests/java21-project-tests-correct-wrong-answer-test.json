// 1 CorrectAnswer, 1 WrongAnswer
{
  "ExecutionType": "tests-execution",
  "ExecutionStrategy": "java-21-project-tests",
  "CompilerType": "JavaZip",
  "FileContent": "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\u003d\u003d",
  "Code": "",
  "TimeLimit": 1200,
  "MemoryLimit": 16777216,
  "ExecutionDetails": {
    "MaxPoints": 100,
    "CheckerType": "trim",
    "CheckerParameter": null,
    "Tests": [
      {
        "Id": 306114,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.Arrays;\r\n\r\npublic class T02ValidateDrinkMethod {\r\n    private static final String METHOD_NOT_PRESENT_ERROR_MESSAGE \u003d \"The method \u0027%s.%s\u0027 does not exist(actual methods parameter types: \u0027%s\u0027 ;expected - \u0027%s\u0027)!\";\r\n    private static final String METHOD_HAS_WRONG_RETURN_TYPE \u003d \"The method \u0027%s.%s()\u0027 has the wrong return type(actual - \u0027%s\u0027; expected - \u0027%s\u0027)!\";\r\n    private static final String METHOD_HAS_PARAMETER_TYPES \u003d \"The method \u0027%s.%s()\u0027 has incorrect parameter types(actual - \u0027%s\u0027; expected - \u0027%s\u0027)!\";\r\n\r\n    private class ExpMethod {\r\n        Class returnType;\r\n        String name;\r\n        Class[] parameterTypes;\r\n\r\n        public ExpMethod(Class returnType, String name, Class... parameterTypes) {\r\n            this.returnType \u003d returnType;\r\n            this.name \u003d name;\r\n            this.parameterTypes \u003d parameterTypes;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void validateClassMethods() {\r\n        Class clazz \u003d getType(\"Drink\");\r\n\r\n        ExpMethod[] methods \u003d new ExpMethod[]{\r\n                new ExpMethod(String.class, \"toString\"),\r\n        };\r\n\r\n        for (ExpMethod method : methods) {\r\n            validateMethod(clazz, method);\r\n        }\r\n    }\r\n\r\n    private void validateMethod(Class clazz, ExpMethod expMethod) {\r\n        String expectedReturnType \u003d expMethod.returnType.toString();\r\n        String expectedName \u003d expMethod.name;\r\n        Class[] expectedParameterTypes \u003d expMethod.parameterTypes;\r\n\r\n        Method actualMethod \u003d getMethod(clazz, expectedName, expectedParameterTypes);\r\n\r\n        // Tests whether the method exist\r\n        String actualMethodsParametersMessage \u003d null;\r\n\r\n        if (actualMethod \u003d\u003d null) {\r\n            actualMethodsParametersMessage \u003d findMethodFromMethods(clazz, expectedName);\r\n        }\r\n\r\n        String existMessage \u003d String.format(METHOD_NOT_PRESENT_ERROR_MESSAGE, clazz.getSimpleName(), expectedName, actualMethodsParametersMessage, arrayToString(expectedParameterTypes));\r\n        Assertions.assertNotNull(actualMethod, existMessage);\r\n\r\n        // Tests whether the method returns correct type\r\n        String actualReturnType \u003d actualMethod.getReturnType().toString();\r\n        String returnTypeMessage \u003d String.format(METHOD_HAS_WRONG_RETURN_TYPE, clazz.getSimpleName(), expectedName, actualReturnType, expectedReturnType);\r\n        Assertions.assertEquals(expectedReturnType, actualReturnType, returnTypeMessage);\r\n    }\r\n\r\n    private String arrayToString(Class[] array) {\r\n        String[] stringArray \u003d Arrays.stream(array).map(Class::getSimpleName).toArray(String[]::new);\r\n        String arrayStr \u003d String.join(\", \", stringArray);\r\n\r\n        return arrayStr;\r\n    }\r\n\r\n    private String findMethodFromMethods(Class clazz, String methodName) {\r\n        Method[] methods \u003d clazz.getMethods();\r\n\r\n        Method[] methodsWithGivenName \u003d Arrays.stream(methods).filter(m -\u003e m.getName().equals(methodName)).toArray(Method[]::new);\r\n\r\n        StringBuilder sb \u003d new StringBuilder();\r\n\r\n        for (Method method : methodsWithGivenName) {\r\n            String parameterTypes \u003d arrayToString(method.getParameterTypes());\r\n            sb.append(\"{ \" + parameterTypes + \" } \");\r\n        }\r\n\r\n        return sb.toString().trim();\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 2
      },
      {
        "Id": 306115,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\n\r\npublic class T03ValidateToStringDrink {\r\n    private static final String METHOD_INCORRECT_RETURN_VALUE \u003d \"Method \u0027%s.%s\u0027 returns invalid data (expected res: \u0027%s\u0027; actual - \u0027%s\u0027)!\";\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"Drink\");\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{\"Drink\", new BigDecimal(\"124\"), 222});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateMethodTestExplanation() {\r\n        // Arrange\r\n        String methodName \u003d \"toString\";\r\n        Object[] methodArgs \u003d new Object[]{};\r\n\r\n        StringBuilder sb \u003d new StringBuilder();\r\n\r\n        String expectedMessage \u003d \"Name: Drink, Price: $124, Volume: 222 ml\";\r\n\r\n\r\n        Class[] paramTypes \u003d new Class[]{};\r\n        System.out.println();\r\n        // Act\r\n        Object actualResult \u003d getMethodValue(this.classType, this.classObject, methodName, methodArgs, paramTypes);\r\n\r\n        // Assert\r\n        String message \u003d String.format(METHOD_INCORRECT_RETURN_VALUE, this.classType.getClass().getSimpleName(), methodName, expectedMessage, actualResult);\r\n        Assertions.assertEquals(expectedMessage, actualResult, message);\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodException(String expectedExceptionName, String expectedExceptionMessage, Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                String testMessage \u003d String.format(METHOD_INCORRECT_EXCEPTION_MESSAGE,\r\n                        clazz.getSimpleName(),\r\n                        methodName,\r\n                        expectedExceptionName,\r\n                        expectedExceptionMessage,\r\n                        e.getTargetException().getClass().getSimpleName(),\r\n                        e.getTargetException().getMessage());\r\n\r\n                Assertions.assertEquals(expectedExceptionMessage, e.getTargetException().getMessage(), testMessage);\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 3
      }
    ],
    "TaskSkeleton": null,
    "TaskSkeletonAsString": null
  },
  "ExecutionOptions": {
    "KeepDetails": true,
    "EscapeTests": false,
    "EscapeLineEndings": true
  },
  "WithExceptionStackTrace": true
}