// Compile time error
{
  "ExecutionType": "tests-execution",
  "ExecutionStrategy": "java-21-project-tests",
  "CompilerType": "JavaZip",
  "FileContent": "UEsDBAoAAAAAAA1z01gAAAAAAAAAAAAAAAAOAAAAdmVuZGluZ1N5c3RlbS9QSwMEFAAAAAgAuJ7SWJuHZwMpAQAAngMAABgAAAB2ZW5kaW5nU3lzdGVtL0RyaW5rLmphdmGVk01qwzAQhfeB3GEIDTggfIAEb0rWpRDoXlUUR40lGUkWlJC7Vz+OLatOaLUwZh7vzacZu8XkgmsKloojE/XhWxvKd8vFcsF4K5WBL2xxybE5l6+s3lPCOG6C3nafDSNAGqw17BUTF7j6OrjTKmaxoXAwrl6DwJzupsoY5kskl5kwYGXTBV8vxX6hU5EEo19ZKLFvPBT0x5yZLr0HqpRpkIIbqgnRIMY8qEYuL90yvB6spubNNSgm7RU1nRJp59xtJTuC7r3JHf9yizwrmYqjefdXmsVJL/uIJ7rzOU/SHg4wz/S7cUAfYYqzRE8HfEfq/c82/a+NGRlfZomiVJ6kcn9CsfLr2cJaIwiD2cLL+oQgEvk68GaFxpD7GT4KlGwEpcPYpIzu8QNQSwMEFAAAAAgAogHSWPnx1el1AgAAMwkAABcAAAB2ZW5kaW5nU3lzdGVtL01haW4uamF2YbVVTWvbQBC9G/wfBtODBEb+CElNTA9NQptCXEpicik9jFdjaZuVVkgrB7f0v3e1cuWVvCF2oMJgdmbem6eZ0WyG7Akjgg2lIU+jh22hKJn3e/0eTzKZK/iJGwwSVHFwxaMbYjxBYfxZuRKcARNYFLBAnsLvfg/0s3MUCpX+20geQqLd3oPKdYbvPwDzqPCr6Dq+ekajLylXHAX/RaBigpwyWXAl8y14j7W2BbKYp+TvUW0HbNrHD5DScyfGu/DnL+alVHGl891onU9WGnMGRbijNGdvsCQcDI1hXxlvMAnOB/4QzsZjf96lYHK9JmqzXBubg2gajCuiydRBFEt1HUsmBaoO3a1U0LicrEbe1CVPQ7p0d6icNGc7Gpc4hllWMsZT2XnTxu7UNTNvO3MQJpLFndovKpOTZmJozl1Fo3yFYtlt460xw0vdfG+30x6cz6QrLctU7Y311xPIUgWZJlci9dozGUSkDMbz/TmMRuM25ccwrFUVe2uHAMOw1q3H0Z+/HlaP3DGR9kwdE2+m5SgJTd+PiTbN7tZ6qdeAkqCDIDT1geeYUrMoNDuy6rPlBaxLIV7P0MzB/+joRZvynhK5obqpp7DmBnc4oXUS+ISioDfzWUTLvKTDItzJNKJCnS47IrXDVuWwab9iQpdg1skQvuWc6dM7vUWG8ChFWfn0LoFEODoSE2ZvVfMPXMlpVNQrdy9Db9q9jIlDxlW5BYQi01thzdnpQlbltrVPbTGnlqTeD3BP1e182ghUiKoQTkJ9zXOBK0GXtvOEgnVBrZvIxtovOHZjjynKgchmzdjJZpbQmRto7hIbM7Ew53YH/vR7+vcXUEsDBBQAAAAIAA1z01gHykQWYgIAAM8IAAAhAAAAdmVuZGluZ1N5c3RlbS9WZW5kaW5nTWFjaGluZS5qYXZh1VbLbtswELwHyD8QPtFGS9/txkDrpkCA9AEEyJ2W1jYbilT5UOsW+feuSFqRZMVReqsOoiByZ2aHu6JKnj3wHZAKVC7U7u5gHRTLy4vLC1GU2jjynVeceSckm4XXpd9IkZFMcmvJfYz6zLO9UED+1AsIXqURFXdAhHJk453Tas2RSbjDsrvgVlj37qMR6mFF8nqwywYjEnUp6CnitKYl6XJ7YVl3nlwNS2iWR15cpuAneW8MPwRVKzpNKx97kmoNO3Br7ZWjHXoDzhuVMmFW/IZnQSotcsLzPCRPwz3GdQDFltBeOqsufGd5faVZhKYRr5Xv47CWjdYSuEL5ha4gKrpzOOyI4gWcSTFG3GwjFXmbxDG05wtG0imDH55LSwPOiRfzWVIQ88eoW612YIdtXWspIXNCK8sK/ity2jf4vii54U4bloVHFH6DWxNAFwtEvdfSD/HP5q9T0KoXZp0BXtBpkDJeAtPmWlqgykvZ6JnNj4r6atZ74OUoQ4Q6a0hLyjcjslGbcZZ82AtUMY79BR8aMakON/5wvi7n86SrL2krpAMzskBxtco/CVPn3FHInI7MtN1PW21Iu3fJItF3pB0b+SxzP4D0em1YAIkbOPCYYmvxp+6+0tuvZV1jXHa+1ORquASOfgevx/i8HP64YF+VtOLSQ40UHloeMByRrdmkyaQpojj8Yxn9X6k+t6MG6rO727Zx6oMXMgdDtHeld+nQ60zRSUjdEjz4heQbCYvJlPGyxIOYxv8DJvEovoPU5XTazit5hJ1xjUf2U9tFwiNOeP0S6oBdCeWkF8JHDG9/AVBLAQIfAAoAAAAAAA1z01gAAAAAAAAAAAAAAAAOACQAAAAAAAAAEAAAAAAAAAB2ZW5kaW5nU3lzdGVtLwoAIAAAAAAAAQAYAOZ0vz47wtoB5nS/PjvC2gGtpKrju8DaAVBLAQIfABQAAAAIALie0libh2cDKQEAAJ4DAAAYACQAAAAAAAAAIAAAACwAAAB2ZW5kaW5nU3lzdGVtL0RyaW5rLmphdmEKACAAAAAAAAEAGABb9OoWoMHaAVv06hagwdoBBw4Iy/HA2gFQSwECHwAUAAAACACiAdJY+fHV6XUCAAAzCQAAFwAkAAAAAAAAACAAAACLAQAAdmVuZGluZ1N5c3RlbS9NYWluLmphdmEKACAAAAAAAAEAGAAQbFEl+8DaARBsUSX7wNoB137vNvjA2gFQSwECHwAUAAAACAANc9NYB8pEFmICAADPCAAAIQAkAAAAAAAAACAAAAA1BAAAdmVuZGluZ1N5c3RlbS9WZW5kaW5nTWFjaGluZS5qYXZhCgAgAAAAAAABABgAXmG/PjvC2gFeYb8+O8LaAe8d9zvywNoBUEsFBgAAAAAEAAQApgEAANYGAAAAAA\u003d\u003d",
  "Code": "",
  "TimeLimit": 1200,
  "MemoryLimit": 16777216,
  "ExecutionDetails": {
    "MaxPoints": 100,
    "CheckerType": "trim",
    "CheckerParameter": null,
    "Tests": [
      {
        "Id": 306110,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\n\r\npublic class T00_1ValidateTypesExist {\r\n    private static final String CLASS_NOT_PRESENT_ERROR_MESSAGE \u003d \"Class \u0027%s\u0027 not present\";\r\n\r\n    @Test\r\n    public void validateTypesExist() {\r\n        String[] classTypesToAssert \u003d new String[]{\r\n                \"Drink\",\r\n                \"VendingMachine\",\r\n        };\r\n\r\n        for (String classType : classTypesToAssert) {\r\n            String message \u003d String.format(CLASS_NOT_PRESENT_ERROR_MESSAGE, classType);\r\n            Assertions.assertNotNull(getType(classType), message);\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": true,
        "OrderBy": 1
      },
      {
        "Id": 306111,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport java.lang.reflect.Field;\r\n\r\npublic class T00_2ValidateFieldsExists {\r\n    private static final String FIELD_NOT_PRESENT_ERROR_MESSAGE \u003d \"The field \u0027%s.%s\u0027 does not exist!\";\r\n\r\n    private class ExpField {\r\n        String name;\r\n\r\n        public ExpField(String name) {\r\n            this.name \u003d name;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void validateClassFields() {\r\n        Class clazzFirstType \u003d getType(\"Drink\");\r\n        ExpField[] fieldsFirstType \u003d new ExpField[]{\r\n                new ExpField(\"name\"),\r\n                new ExpField(\"price\"),\r\n                new ExpField(\"volume\"),\r\n        };\r\n\r\n        for (ExpField field : fieldsFirstType) {\r\n            validateField(clazzFirstType, field);\r\n        }\r\n\r\n\r\n        Class clazzSecondType \u003d getType(\"VendingMachine\");\r\n        ExpField[] fieldsSecondType \u003d new ExpField[]{\r\n                new ExpField(\"buttonCapacity\"),\r\n                new ExpField(\"drinks\"),\r\n        };\r\n\r\n        for (ExpField field : fieldsSecondType) {\r\n            validateField(clazzSecondType, field);\r\n        }\r\n    }\r\n\r\n    private void validateField(Class clazz, ExpField expField) {\r\n        String expectedName \u003d expField.name;\r\n\r\n        // Returns null if the field does not exist\r\n        Field actualField \u003d getField(clazz, expectedName);\r\n\r\n        // Tests whether the field exist\r\n        String nameMessage \u003d String.format(FIELD_NOT_PRESENT_ERROR_MESSAGE, clazz.getSimpleName(), expectedName);\r\n        Assertions.assertNotNull(actualField, nameMessage);\r\n    }\r\n\r\n    private Field getField(Class clazz, String expectedName) {\r\n        Field field \u003d null;\r\n        try {\r\n            field \u003d clazz.getDeclaredField(expectedName);\r\n        } catch (NoSuchFieldException e) {\r\n        }\r\n\r\n        return field;\r\n    }\r\n\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": true,
        "OrderBy": 2
      },
      {
        "Id": 306112,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.Arrays;\r\n\r\npublic class T00_3ValidateMethodsExists {\r\n    private static final String METHOD_NOT_PRESENT_ERROR_MESSAGE \u003d \"The method \u0027%s.%s\u0027 does not exist(actual methods parameter types: \u0027%s\u0027 ;expected - \u0027%s\u0027)!\";\r\n\r\n    private class ExpMethod {\r\n        String name;\r\n        Class[] parameterTypes;\r\n\r\n        public ExpMethod(String name, Class... parameterTypes) {\r\n            this.name \u003d name;\r\n            this.parameterTypes \u003d parameterTypes;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void validateClassMethods() {\r\n        Class carClazz \u003d getType(\"Drink\");\r\n\r\n        ExpMethod[] carMethods \u003d new ExpMethod[]{\r\n                new ExpMethod(\"getName\"),\r\n                new ExpMethod(\"getPrice\"),\r\n                new ExpMethod(\"getVolume\"),\r\n        };\r\n\r\n        for (ExpMethod method : carMethods) {\r\n            validateMethod(carClazz, method);\r\n        }\r\n\r\n        Class parkingClazz \u003d getType(\"VendingMachine\");\r\n\r\n        ExpMethod[] parkingMethods \u003d new ExpMethod[]{\r\n                new ExpMethod(\"addDrink\", getType(\"Drink\")),\r\n                new ExpMethod(\"removeDrink\", String.class),\r\n                new ExpMethod(\"getCount\"),\r\n                new ExpMethod(\"getLongest\"),\r\n                new ExpMethod(\"getCheapest\"),\r\n                new ExpMethod(\"buyDrink\", String.class),\r\n                new ExpMethod(\"report\"),\r\n        };\r\n\r\n        for (ExpMethod method : parkingMethods) {\r\n            validateMethod(parkingClazz, method);\r\n        }\r\n    }\r\n\r\n    private void validateMethod(Class clazz, ExpMethod expMethod) {\r\n        String expectedName \u003d expMethod.name;\r\n        Class[] expectedParameterTypes \u003d expMethod.parameterTypes;\r\n\r\n        Method actualMethod \u003d getMethod(clazz, expectedName, expectedParameterTypes);\r\n\r\n        // Tests whether the method exist\r\n        String actualMethodsParametersMessage \u003d null;\r\n\r\n        if (actualMethod \u003d\u003d null) {\r\n            actualMethodsParametersMessage \u003d findMethodFromMethods(clazz, expectedName);\r\n        }\r\n\r\n        String existMessage \u003d String.format(METHOD_NOT_PRESENT_ERROR_MESSAGE, clazz.getSimpleName(), expectedName, actualMethodsParametersMessage, arrayToString(expectedParameterTypes));\r\n        Assertions.assertNotNull(actualMethod, existMessage);\r\n    }\r\n\r\n    private String arrayToString(Class[] array) {\r\n        String[] stringArray \u003d Arrays.stream(array).map(Class::getSimpleName).toArray(String[]::new);\r\n        String arrayStr \u003d String.join(\", \", stringArray);\r\n\r\n        return arrayStr;\r\n    }\r\n\r\n    private String findMethodFromMethods(Class clazz, String methodName) {\r\n        Method[] methods \u003d clazz.getMethods();\r\n\r\n        Method[] methodsWithGivenName \u003d Arrays.stream(methods).filter(m -\u003e m.getName().equals(methodName)).toArray(Method[]::new);\r\n\r\n        StringBuilder sb \u003d new StringBuilder();\r\n\r\n        for (Method method : methodsWithGivenName) {\r\n            String parameterTypes \u003d arrayToString(method.getParameterTypes());\r\n            sb.append(\"{ \" + parameterTypes + \" } \");\r\n        }\r\n\r\n        return sb.toString().trim();\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": true,
        "OrderBy": 3
      },
      {
        "Id": 306113,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Modifier;\r\nimport java.math.BigDecimal;\r\n\r\npublic class T01ValidateDrinkFields {\r\n    private static final String MODIFIER_PRIVATE \u003d \"private\";\r\n    private static final String FIELD_NOT_PRESENT_ERROR_MESSAGE \u003d \"The field \u0027%s.%s\u0027 does not exist!\";\r\n    private static final String FIELD_IS_NOT_CORRECT_MODIFIER \u003d \"The field \u0027%s.%s\u0027 doesn\u0027t have correct access modifier(actual - `%s`; expected - `%s`;)!\";\r\n    private static final String FIELD_HAS_WRONG_TYPE \u003d \"The field \u0027%s.%s\u0027 has the wrong type(actual - `%s`; expected - `%s`;)!\";\r\n\r\n    private class ExpField {\r\n        Class fieldType;\r\n        String modifier;\r\n        String name;\r\n\r\n        public ExpField(String modifier, Class fieldType, String name) {\r\n            this.fieldType \u003d fieldType;\r\n            this.modifier \u003d modifier;\r\n            this.name \u003d name;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void validateClassFields() {\r\n        Class clazz \u003d getType(\"Drink\");\r\n\r\n        ExpField[] fields \u003d new ExpField[]{\r\n                new ExpField(MODIFIER_PRIVATE, String.class, \"name\"),\r\n                new ExpField(MODIFIER_PRIVATE, BigDecimal.class, \"price\"),\r\n                new ExpField(MODIFIER_PRIVATE, int.class, \"volume\"),\r\n        };\r\n\r\n        for (ExpField field : fields) {\r\n            validateField(clazz, field);\r\n        }\r\n    }\r\n\r\n    private void validateField(Class clazz, ExpField expField) {\r\n        String expectedModifier \u003d expField.modifier;\r\n        String expectedType \u003d expField.fieldType.toString();\r\n        String expectedName \u003d expField.name;\r\n\r\n        // Returns null if the field does not exist\r\n        Field actualField \u003d getField(clazz, expectedName);\r\n\r\n        // Tests whether the field exist\r\n        String nameMessage \u003d String.format(FIELD_NOT_PRESENT_ERROR_MESSAGE, clazz.getSimpleName(), expectedName);\r\n        Assertions.assertNotNull(actualField, nameMessage);\r\n\r\n        // Tests whether the modifier is private\r\n        String actualModifier \u003d getFieldModifier(actualField);\r\n        String modifierMessage \u003d String.format(FIELD_IS_NOT_CORRECT_MODIFIER, clazz.getSimpleName(), expectedName, actualModifier, expectedModifier);\r\n        Assertions.assertEquals(expectedModifier, actualModifier, modifierMessage);\r\n\r\n        // Tests whether the field type is correct\r\n        String actualType \u003d actualField.getType().toString();\r\n        String typeMessage \u003d String.format(FIELD_HAS_WRONG_TYPE, clazz.getSimpleName(), expectedName, actualType, expectedType);\r\n        Assertions.assertEquals(expectedType, actualType, typeMessage);\r\n    }\r\n\r\n    private Field getField(Class clazz, String expectedName) {\r\n        Field field \u003d null;\r\n        try {\r\n            field \u003d clazz.getDeclaredField(expectedName);\r\n        } catch (NoSuchFieldException e) {\r\n        }\r\n\r\n        return field;\r\n    }\r\n\r\n    private String getFieldModifier(Field field) {\r\n        int actualModifier \u003d field.getModifiers();\r\n\r\n        String modifierAsStr \u003d Modifier.toString(actualModifier);\r\n        return modifierAsStr;\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 1
      },
      {
        "Id": 306114,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.Arrays;\r\n\r\npublic class T02ValidateDrinkMethod {\r\n    private static final String METHOD_NOT_PRESENT_ERROR_MESSAGE \u003d \"The method \u0027%s.%s\u0027 does not exist(actual methods parameter types: \u0027%s\u0027 ;expected - \u0027%s\u0027)!\";\r\n    private static final String METHOD_HAS_WRONG_RETURN_TYPE \u003d \"The method \u0027%s.%s()\u0027 has the wrong return type(actual - \u0027%s\u0027; expected - \u0027%s\u0027)!\";\r\n    private static final String METHOD_HAS_PARAMETER_TYPES \u003d \"The method \u0027%s.%s()\u0027 has incorrect parameter types(actual - \u0027%s\u0027; expected - \u0027%s\u0027)!\";\r\n\r\n    private class ExpMethod {\r\n        Class returnType;\r\n        String name;\r\n        Class[] parameterTypes;\r\n\r\n        public ExpMethod(Class returnType, String name, Class... parameterTypes) {\r\n            this.returnType \u003d returnType;\r\n            this.name \u003d name;\r\n            this.parameterTypes \u003d parameterTypes;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void validateClassMethods() {\r\n        Class clazz \u003d getType(\"Drink\");\r\n\r\n        ExpMethod[] methods \u003d new ExpMethod[]{\r\n                new ExpMethod(String.class, \"toString\"),\r\n        };\r\n\r\n        for (ExpMethod method : methods) {\r\n            validateMethod(clazz, method);\r\n        }\r\n    }\r\n\r\n    private void validateMethod(Class clazz, ExpMethod expMethod) {\r\n        String expectedReturnType \u003d expMethod.returnType.toString();\r\n        String expectedName \u003d expMethod.name;\r\n        Class[] expectedParameterTypes \u003d expMethod.parameterTypes;\r\n\r\n        Method actualMethod \u003d getMethod(clazz, expectedName, expectedParameterTypes);\r\n\r\n        // Tests whether the method exist\r\n        String actualMethodsParametersMessage \u003d null;\r\n\r\n        if (actualMethod \u003d\u003d null) {\r\n            actualMethodsParametersMessage \u003d findMethodFromMethods(clazz, expectedName);\r\n        }\r\n\r\n        String existMessage \u003d String.format(METHOD_NOT_PRESENT_ERROR_MESSAGE, clazz.getSimpleName(), expectedName, actualMethodsParametersMessage, arrayToString(expectedParameterTypes));\r\n        Assertions.assertNotNull(actualMethod, existMessage);\r\n\r\n        // Tests whether the method returns correct type\r\n        String actualReturnType \u003d actualMethod.getReturnType().toString();\r\n        String returnTypeMessage \u003d String.format(METHOD_HAS_WRONG_RETURN_TYPE, clazz.getSimpleName(), expectedName, actualReturnType, expectedReturnType);\r\n        Assertions.assertEquals(expectedReturnType, actualReturnType, returnTypeMessage);\r\n    }\r\n\r\n    private String arrayToString(Class[] array) {\r\n        String[] stringArray \u003d Arrays.stream(array).map(Class::getSimpleName).toArray(String[]::new);\r\n        String arrayStr \u003d String.join(\", \", stringArray);\r\n\r\n        return arrayStr;\r\n    }\r\n\r\n    private String findMethodFromMethods(Class clazz, String methodName) {\r\n        Method[] methods \u003d clazz.getMethods();\r\n\r\n        Method[] methodsWithGivenName \u003d Arrays.stream(methods).filter(m -\u003e m.getName().equals(methodName)).toArray(Method[]::new);\r\n\r\n        StringBuilder sb \u003d new StringBuilder();\r\n\r\n        for (Method method : methodsWithGivenName) {\r\n            String parameterTypes \u003d arrayToString(method.getParameterTypes());\r\n            sb.append(\"{ \" + parameterTypes + \" } \");\r\n        }\r\n\r\n        return sb.toString().trim();\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 2
      },
      {
        "Id": 306115,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\n\r\npublic class T03ValidateToStringDrink {\r\n    private static final String METHOD_INCORRECT_RETURN_VALUE \u003d \"Method \u0027%s.%s\u0027 returns invalid data (expected res: \u0027%s\u0027; actual - \u0027%s\u0027)!\";\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"Drink\");\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{\"Drink\", new BigDecimal(\"124\"), 222});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateMethodTestExplanation() {\r\n        // Arrange\r\n        String methodName \u003d \"toString\";\r\n        Object[] methodArgs \u003d new Object[]{};\r\n\r\n        StringBuilder sb \u003d new StringBuilder();\r\n\r\n        String expectedMessage \u003d \"Name: Drink, Price: $124, Volume: 222 ml\";\r\n\r\n\r\n        Class[] paramTypes \u003d new Class[]{};\r\n        System.out.println();\r\n        // Act\r\n        Object actualResult \u003d getMethodValue(this.classType, this.classObject, methodName, methodArgs, paramTypes);\r\n\r\n        // Assert\r\n        String message \u003d String.format(METHOD_INCORRECT_RETURN_VALUE, this.classType.getClass().getSimpleName(), methodName, expectedMessage, actualResult);\r\n        Assertions.assertEquals(expectedMessage, actualResult, message);\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodException(String expectedExceptionName, String expectedExceptionMessage, Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                String testMessage \u003d String.format(METHOD_INCORRECT_EXCEPTION_MESSAGE,\r\n                        clazz.getSimpleName(),\r\n                        methodName,\r\n                        expectedExceptionName,\r\n                        expectedExceptionMessage,\r\n                        e.getTargetException().getClass().getSimpleName(),\r\n                        e.getTargetException().getMessage());\r\n\r\n                Assertions.assertEquals(expectedExceptionMessage, e.getTargetException().getMessage(), testMessage);\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 3
      },
      {
        "Id": 306116,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\n\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Modifier;\r\nimport java.util.List;\r\n\r\npublic class T04ValidateVendingMachineFields {\r\n    private static final String MODIFIER_PRIVATE \u003d \"private\";\r\n    private static final String FIELD_NOT_PRESENT_ERROR_MESSAGE \u003d \"The field \u0027%s.%s\u0027 does not exist!\";\r\n    private static final String FIELD_IS_NOT_CORRECT_MODIFIER \u003d \"The field \u0027%s.%s\u0027 doesn\u0027t have correct access modifier(actual - `%s`; expected - `%s`;)!\";\r\n    private static final String FIELD_HAS_WRONG_TYPE \u003d \"The field \u0027%s.%s\u0027 has the wrong type(actual - `%s`; expected - `%s`;)!\";\r\n\r\n    private class ExpField {\r\n        Class fieldType;\r\n        String modifier;\r\n        String name;\r\n\r\n        public ExpField(String modifier, Class fieldType, String name) {\r\n            this.fieldType \u003d fieldType;\r\n            this.modifier \u003d modifier;\r\n            this.name \u003d name;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void validateClassFields() {\r\n        Class clazz \u003d getType(\"VendingMachine\");\r\n\r\n        ExpField[] fields \u003d new ExpField[]{\r\n                new ExpField(MODIFIER_PRIVATE, int.class, \"buttonCapacity\"),\r\n                new ExpField(MODIFIER_PRIVATE, List.class, \"drinks\"),\r\n        };\r\n\r\n        for (ExpField field : fields) {\r\n            validateField(clazz, field);\r\n        }\r\n    }\r\n\r\n    private void validateField(Class clazz, ExpField expField) {\r\n        String expectedModifier \u003d expField.modifier;\r\n        String expectedType \u003d expField.fieldType.toString();\r\n        String expectedName \u003d expField.name;\r\n\r\n        // Returns null if the field does not exist\r\n        Field actualField \u003d getField(clazz, expectedName);\r\n\r\n        // Tests whether the field exist\r\n        String nameMessage \u003d String.format(FIELD_NOT_PRESENT_ERROR_MESSAGE, clazz.getSimpleName(), expectedName);\r\n        Assertions.assertNotNull(actualField, nameMessage);\r\n\r\n        // Tests whether the modifier is private\r\n        String actualModifier \u003d getFieldModifier(actualField);\r\n        String modifierMessage \u003d String.format(FIELD_IS_NOT_CORRECT_MODIFIER, clazz.getSimpleName(), expectedName, actualModifier, expectedModifier);\r\n        Assertions.assertEquals(expectedModifier, actualModifier, modifierMessage);\r\n\r\n        // Tests whether the field type is correct\r\n        String actualType \u003d actualField.getType().toString();\r\n        String typeMessage \u003d String.format(FIELD_HAS_WRONG_TYPE, clazz.getSimpleName(), expectedName, actualType, expectedType);\r\n        Assertions.assertEquals(expectedType, actualType, typeMessage);\r\n    }\r\n\r\n    private Field getField(Class clazz, String expectedName) {\r\n        Field field \u003d null;\r\n        try {\r\n            field \u003d clazz.getDeclaredField(expectedName);\r\n        } catch (NoSuchFieldException e) {\r\n        }\r\n\r\n        return field;\r\n    }\r\n\r\n    private String getFieldModifier(Field field) {\r\n        int actualModifier \u003d field.getModifiers();\r\n\r\n        String modifierAsStr \u003d Modifier.toString(actualModifier);\r\n        return modifierAsStr;\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 4
      },
      {
        "Id": 306117,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.Arrays;\r\n\r\npublic class T05ValidateVendingMachineMethods {\r\n    private static final String METHOD_NOT_PRESENT_ERROR_MESSAGE \u003d \"The method \u0027%s.%s\u0027 does not exist(actual methods parameter types: \u0027%s\u0027 ;expected - \u0027%s\u0027)!\";\r\n    private static final String METHOD_HAS_WRONG_RETURN_TYPE \u003d \"The method \u0027%s.%s()\u0027 has the wrong return type(actual - \u0027%s\u0027; expected - \u0027%s\u0027)!\";\r\n    private static final String METHOD_HAS_PARAMETER_TYPES \u003d \"The method \u0027%s.%s()\u0027 has incorrect parameter types(actual - \u0027%s\u0027; expected - \u0027%s\u0027)!\";\r\n\r\n    private class ExpMethod {\r\n        Class returnType;\r\n        String name;\r\n        Class[] parameterTypes;\r\n\r\n        public ExpMethod(Class returnType, String name, Class... parameterTypes) {\r\n            this.returnType \u003d returnType;\r\n            this.name \u003d name;\r\n            this.parameterTypes \u003d parameterTypes;\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void validateClassMethods() {\r\n        Class clazz \u003d getType(\"VendingMachine\");\r\n        Class childClazz \u003d getType(\"Drink\");\r\n\r\n        ExpMethod[] methods \u003d new ExpMethod[]{\r\n                new ExpMethod(void.class, \"addDrink\", childClazz),\r\n                new ExpMethod(boolean.class, \"removeDrink\", String.class),\r\n                new ExpMethod(int.class, \"getCount\"),\r\n                new ExpMethod(childClazz, \"getLongest\"),\r\n                new ExpMethod(childClazz, \"getCheapest\"),\r\n                new ExpMethod(String.class, \"buyDrink\", String.class),\r\n                new ExpMethod(String.class, \"report\"),\r\n\r\n        };\r\n\r\n        for (ExpMethod method : methods) {\r\n            validateMethod(clazz, method);\r\n        }\r\n    }\r\n\r\n    private void validateMethod(Class clazz, ExpMethod expMethod) {\r\n        String expectedReturnType \u003d expMethod.returnType.toString();\r\n        String expectedName \u003d expMethod.name;\r\n        Class[] expectedParameterTypes \u003d expMethod.parameterTypes;\r\n\r\n        Method actualMethod \u003d getMethod(clazz, expectedName, expectedParameterTypes);\r\n\r\n        // Tests whether the method exist\r\n        String actualMethodsParametersMessage \u003d null;\r\n\r\n        if (actualMethod \u003d\u003d null) {\r\n            actualMethodsParametersMessage \u003d findMethodFromMethods(clazz, expectedName);\r\n        }\r\n\r\n        String existMessage \u003d String.format(METHOD_NOT_PRESENT_ERROR_MESSAGE, clazz.getSimpleName(), expectedName, actualMethodsParametersMessage, arrayToString(expectedParameterTypes));\r\n        Assertions.assertNotNull(actualMethod, existMessage);\r\n\r\n        // Tests whether the method returns correct type\r\n        String actualReturnType \u003d actualMethod.getReturnType().toString();\r\n        String returnTypeMessage \u003d String.format(METHOD_HAS_WRONG_RETURN_TYPE, clazz.getSimpleName(), expectedName, actualReturnType, expectedReturnType);\r\n        Assertions.assertEquals(expectedReturnType, actualReturnType, returnTypeMessage);\r\n    }\r\n\r\n    private String arrayToString(Class[] array) {\r\n        String[] stringArray \u003d Arrays.stream(array).map(Class::getSimpleName).toArray(String[]::new);\r\n        String arrayStr \u003d String.join(\", \", stringArray);\r\n\r\n        return arrayStr;\r\n    }\r\n\r\n    private String findMethodFromMethods(Class clazz, String methodName) {\r\n        Method[] methods \u003d clazz.getMethods();\r\n\r\n        Method[] methodsWithGivenName \u003d Arrays.stream(methods).filter(m -\u003e m.getName().equals(methodName)).toArray(Method[]::new);\r\n\r\n        StringBuilder sb \u003d new StringBuilder();\r\n\r\n        for (Method method : methodsWithGivenName) {\r\n            String parameterTypes \u003d arrayToString(method.getParameterTypes());\r\n            sb.append(\"{ \" + parameterTypes + \" } \");\r\n        }\r\n\r\n        return sb.toString().trim();\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 5
      },
      {
        "Id": 306118,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport vendingSystem.Drink;\r\n\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class T06ValidateVengingMachineAddMethod {\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"VendingMachine\");\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{2});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateAddClothMethod() {\r\n        Object cloth1 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Cola\",new BigDecimal(\"123\"), 123});\r\n\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{cloth1},getType(\"Drink\"));\r\n\r\n        int size \u003d 0;\r\n        List\u003cDrink\u003e clothList \u003d new ArrayList\u003c\u003e();\r\n\r\n        try {\r\n            Field dataField \u003d this.classObject.getDeclaredField(\"drinks\");\r\n            dataField.setAccessible(true);\r\n            clothList \u003d (List\u003cDrink\u003e)dataField.get(this.classType);\r\n            size \u003d clothList.size();\r\n\r\n        } catch (NoSuchFieldException e) {\r\n\r\n        } catch (IllegalAccessException e) {\r\n\r\n        }\r\n\r\n        // Set expected results\r\n        int expectedMagazineSize \u003d 1;\r\n        Assertions.assertEquals(expectedMagazineSize,size, \"method add doesn\u0027t add in collection data\");\r\n\r\n        //Assertions with exceeding capacity\r\n        Object cloth2 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Red\",new BigDecimal(\"22\"),111});\r\n        Object cloth3 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Blue\",new BigDecimal(\"12\"),222});\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{cloth2},getType(\"Drink\"));\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{cloth3},getType(\"Drink\"));\r\n        size \u003d clothList.size();\r\n        Assertions.assertEquals(2,size);\r\n\r\n        //    String fieldNameMessage \u003d String.format(METHOD_INCORRECT_RETURN_VALUE, this.classObject.getSimpleName(), \"methodName\", actualFieldName, expectedFieldName);\r\n        // Create messages for all fields if assert fail\r\n\r\n        //   Assertions.assertEquals(fieldNameMessage, expectedFieldName, actualFieldName);\r\n        // Test all methods\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n\r\n                method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodException(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodExceptionWithMessageTest(String expectedExceptionName, String expectedExceptionMessage, Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                String testMessage \u003d String.format(METHOD_INCORRECT_EXCEPTION_MESSAGE,\r\n                        clazz.getSimpleName(),\r\n                        methodName,\r\n                        expectedExceptionName,\r\n                        expectedExceptionMessage,\r\n                        e.getTargetException().getClass().getSimpleName(),\r\n                        e.getTargetException().getMessage());\r\n\r\n                Assertions.assertEquals(expectedExceptionMessage, e.getTargetException().getMessage(), testMessage);\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 6
      },
      {
        "Id": 306119,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport vendingSystem.Drink;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class T07ValidateVendingMachineAddWithoutCapacityMethod {\r\n    private static final String METHOD_INCORRECT_RETURN_VALUE \u003d \"Method \u0027%s.%s\u0027 returns invalid data (expected res: \u0027%s\u0027; actual - \u0027%s\u0027)!\";\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"VendingMachine\");\r\n        Class controllerClass1 \u003d getType(\"Drink\");\r\n        Assertions.assertNotNull(String.format(\"%s class not present\",controllerClass));\r\n        Assertions.assertNotNull(String.format(\"%s class not present\",controllerClass1));\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{1});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateAddMethod() {\r\n        Object[] empArguments \u003d new Object[]{\"Koko\", new BigDecimal(\"5\"), 111};\r\n        Object[] empArguments1 \u003d new Object[]{\"Poli\", new BigDecimal(\"6\"), 222};\r\n        Class childClazz \u003d getType(\"Drink\");\r\n        Object childObject \u003d createObjectInstance(childClazz, empArguments);\r\n        Object childObject1 \u003d createObjectInstance(childClazz, empArguments1);\r\n\r\n\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{childObject}, childClazz);\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{childObject1}, childClazz);\r\n        // Get all method return values\r\n\r\n        Object expectedSize \u003d 1;\r\n        // Set all expected results\r\n        int size \u003d -1;\r\n        try {\r\n            Field field \u003d classObject.getDeclaredField(\"drinks\");\r\n            field.setAccessible(true);\r\n            List\u003cDrink\u003e list \u003d (List\u003cDrink\u003e) field.get(this.classType);\r\n            size \u003d list.size();\r\n        } catch (NoSuchFieldException | IllegalAccessException nsfe) {\r\n            nsfe.printStackTrace();\r\n        }\r\n        // String fieldNameMessage \u003d String.format(METHOD_INCORRECT_RETURN_VALUE, this.classObject.getSimpleName(), \"add\", actualFieldName, expectedFieldName);\r\n        // Create messages for all fields if assert fail\r\n\r\n        Assertions.assertEquals(expectedSize, size, \"Method add should not have size bigger than capacity\");\r\n        // Test all methods\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodException(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodExceptionWithMessageTest(String expectedExceptionName, String expectedExceptionMessage, Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                String testMessage \u003d String.format(METHOD_INCORRECT_EXCEPTION_MESSAGE,\r\n                        clazz.getSimpleName(),\r\n                        methodName,\r\n                        expectedExceptionName,\r\n                        expectedExceptionMessage,\r\n                        e.getTargetException().getClass().getSimpleName(),\r\n                        e.getTargetException().getMessage());\r\n\r\n                Assertions.assertEquals(expectedExceptionMessage, e.getTargetException().getMessage(), testMessage);\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 7
      },
      {
        "Id": 306120,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport vendingSystem.Drink;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class T08ValidateVehicleRemoveMethod {\r\n    private static final String METHOD_INCORRECT_RETURN_VALUE \u003d \"Method \u0027%s.%s\u0027 returns invalid data (expected res: \u0027%s\u0027; actual - \u0027%s\u0027)!\";\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"VendingMachine\");\r\n        Class controllerClass1 \u003d getType(\"Drink\");\r\n        Assertions.assertNotNull(String.format(\"%s class not present\",controllerClass));\r\n        Assertions.assertNotNull(String.format(\"%s class not present\",controllerClass1));\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{4});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateRemoveMethod() {\r\n        Object[] empArguments \u003d new Object[]{\"AAA123\", new BigDecimal(\"222\"), 342};\r\n        Class empClazz \u003d getType(\"Drink\");\r\n        Object empObject \u003d createObjectInstance(empClazz, empArguments);\r\n        Object empObject1 \u003d createObjectInstance(empClazz, new Object[]{\"BB123\", new BigDecimal(\"55\"), 122});\r\n\r\n\r\n        Object actualFieldName \u003d getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{empObject}, empClazz);\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{empObject1}, empClazz);\r\n        Object result \u003d getMethodValue(this.classType, this.classObject, \"removeDrink\", new Object[]{\"BB123\"}, String.class);\r\n        // Get all method return values\r\n\r\n        Assertions.assertEquals(true,result, \"incorect result in remove method\");\r\n        result \u003d  getMethodValue(this.classType, this.classObject, \"removeDrink\", new Object[]{\"InvalidName\"}, String.class);\r\n        Assertions.assertEquals(false,result, \"incorect result when trying to remove invalid Object\");\r\n        Object expectedFieldName \u003d 1;\r\n        // Set all expected results\r\n        int size \u003d -1;\r\n        try {\r\n            Field field \u003d getType(\"VendingMachine\").getDeclaredField(\"drinks\");\r\n            field.setAccessible(true);\r\n            List\u003cDrink\u003e list \u003d (List\u003cDrink\u003e) field.get(this.classType);\r\n            size \u003d list.size();\r\n        } catch (NoSuchFieldException | IllegalAccessException nsfe) {\r\n            nsfe.printStackTrace();\r\n        }\r\n        //String fieldNameMessage \u003d String.format(METHOD_INCORRECT_RETURN_VALUE, this.classObject.getSimpleName(), \"add\", actualFieldName, expectedFieldName);\r\n        // Create messages for all fields if assert fail\r\n\r\n        Assertions.assertEquals(expectedFieldName, size, \"Incorrect size after removing object\");\r\n        // Test all methods\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodException(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodExceptionWithMessageTest(String expectedExceptionName, String expectedExceptionMessage, Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                String testMessage \u003d String.format(METHOD_INCORRECT_EXCEPTION_MESSAGE,\r\n                        clazz.getSimpleName(),\r\n                        methodName,\r\n                        expectedExceptionName,\r\n                        expectedExceptionMessage,\r\n                        e.getTargetException().getClass().getSimpleName(),\r\n                        e.getTargetException().getMessage());\r\n\r\n                Assertions.assertEquals(expectedExceptionMessage, e.getTargetException().getMessage(), testMessage);\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 8
      },
      {
        "Id": 306121,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class T09ValidateVendingMachineGetCountMethod {\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"VendingMachine\");\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{3});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateChildren() {\r\n        Object child1 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Yellow\", new BigDecimal(\"12\"), 123});\r\n        Object child2 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Red\",new BigDecimal(\"121\"), 1123});\r\n        Object child3 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Blue\",new BigDecimal(\"1211\"), 1123});\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{child1},getType(\"Drink\"));\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{child2},getType(\"Drink\"));\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{child3},getType(\"Drink\"));\r\n\r\n        int actualCount \u003d (int)getMethodValue(this.classType, this.classObject, \"getCount\", new Object[]{});\r\n        int size \u003d 0;\r\n        List\u003cObject\u003e children \u003d new ArrayList\u003c\u003e();\r\n\r\n        try {\r\n            Field dataField \u003d this.classObject.getDeclaredField(\"drinks\");\r\n            dataField.setAccessible(true);\r\n            children \u003d (List\u003cObject\u003e)dataField.get(this.classType);\r\n            size \u003d children.size();\r\n\r\n        } catch (NoSuchFieldException e) {\r\n\r\n        } catch (IllegalAccessException e) {\r\n\r\n        }\r\n\r\n        // Set expected results\r\n        int expectedBasketSize \u003d size;\r\n\r\n        //Assert independently from add method\r\n        Assertions.assertEquals(expectedBasketSize,actualCount, \"method getCount doesn\u0027t return correct count\");\r\n\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodException(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodExceptionWithMessageTest(String expectedExceptionName, String expectedExceptionMessage, Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                String testMessage \u003d String.format(METHOD_INCORRECT_EXCEPTION_MESSAGE,\r\n                        clazz.getSimpleName(),\r\n                        methodName,\r\n                        expectedExceptionName,\r\n                        expectedExceptionMessage,\r\n                        e.getTargetException().getClass().getSimpleName(),\r\n                        e.getTargetException().getMessage());\r\n\r\n                Assertions.assertEquals(expectedExceptionMessage, e.getTargetException().getMessage(), testMessage);\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 9
      },
      {
        "Id": 306122,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\n\r\npublic class T10ValidateGetLongestMethod {\r\n    private static final String METHOD_INCORRECT_RETURN_VALUE \u003d \"Method \u0027%s.%s\u0027 returns invalid data (expected res: \u0027%s\u0027; actual - \u0027%s\u0027)!\";\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"VendingMachine\");\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{3});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateGetLongestMethod() {\r\n        Object vehicle1 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Yellow\", new BigDecimal(\"12\"), 111});\r\n        Object vehicle2 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Red\", new BigDecimal(\"13\"), 112});\r\n        Object vehicle3 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Blue\", new BigDecimal(\"14\"), 113});\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{vehicle1},getType(\"Drink\"));\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{vehicle2},getType(\"Drink\"));\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{vehicle3},getType(\"Drink\"));\r\n\r\n\r\n        Object actualResultFromGetLowestMileageMethod \u003d getMethodValue(this.classType, this.classObject, \"getLongest\", new Object[]{});\r\n\r\n        // Get method return values\r\n\r\n        Object expectedMileage \u003d vehicle3;\r\n        // Set all expected results\r\n\r\n        String fieldNameMessage \u003d String.format(METHOD_INCORRECT_RETURN_VALUE, this.classObject.getSimpleName(), \"getLongest\", expectedMileage,actualResultFromGetLowestMileageMethod);\r\n        // Create messages for all fields if assert fail\r\n\r\n        Assertions.assertEquals(expectedMileage, actualResultFromGetLowestMileageMethod, fieldNameMessage);\r\n        // Test all methods\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 10
      },
      {
        "Id": 306123,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\n\r\npublic class T11ValidateGetCheapestMethod {\r\n    private static final String METHOD_INCORRECT_RETURN_VALUE \u003d \"Method \u0027%s.%s\u0027 returns invalid data (expected res: \u0027%s\u0027; actual - \u0027%s\u0027)!\";\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"VendingMachine\");\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{3});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateGetLongestMethod() {\r\n        Object vehicle1 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Yellow\", new BigDecimal(\"12\"), 111});\r\n        Object vehicle2 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Red\", new BigDecimal(\"13\"), 112});\r\n        Object vehicle3 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Blue\", new BigDecimal(\"14\"), 113});\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{vehicle1},getType(\"Drink\"));\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{vehicle2},getType(\"Drink\"));\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{vehicle3},getType(\"Drink\"));\r\n\r\n\r\n        Object actualResultFromGetLowestMileageMethod \u003d getMethodValue(this.classType, this.classObject, \"getCheapest\", new Object[]{});\r\n\r\n        // Get method return values\r\n\r\n        Object expectedMileage \u003d vehicle1;\r\n        // Set all expected results\r\n\r\n        String fieldNameMessage \u003d String.format(METHOD_INCORRECT_RETURN_VALUE, this.classObject.getSimpleName(), \"getCheapest\", expectedMileage,actualResultFromGetLowestMileageMethod);\r\n        // Create messages for all fields if assert fail\r\n\r\n        Assertions.assertEquals(expectedMileage, actualResultFromGetLowestMileageMethod, fieldNameMessage);\r\n        // Test all methods\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 11
      },
      {
        "Id": 306124,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport vendingSystem.Drink;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class T12ValidateBuyDrinksMethod {\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"VendingMachine\");\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{2});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateAddClothMethod() {\r\n        Object cloth1 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Cola\",new BigDecimal(\"123\"), 123});\r\n\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{cloth1},getType(\"Drink\"));\r\n\r\n        int size \u003d 0;\r\n        List\u003cDrink\u003e clothList \u003d new ArrayList\u003c\u003e();\r\n\r\n        try {\r\n            Field dataField \u003d this.classObject.getDeclaredField(\"drinks\");\r\n            dataField.setAccessible(true);\r\n            clothList \u003d (List\u003cDrink\u003e)dataField.get(this.classType);\r\n            size \u003d clothList.size();\r\n\r\n        } catch (NoSuchFieldException e) {\r\n\r\n        } catch (IllegalAccessException e) {\r\n\r\n        }\r\n\r\n        // Set expected results\r\n        int expectedMagazineSize \u003d 1;\r\n        Assertions.assertEquals(expectedMagazineSize,size, \"method add doesn\u0027t add in collection data\");\r\n\r\n        //Assertions with exceeding capacity\r\n        Object cloth2 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Red\",new BigDecimal(\"22\"),111});\r\n        Object cloth3 \u003d createObjectInstance(getType(\"Drink\"),new Object[]{\"Blue\",new BigDecimal(\"12\"),222});\r\n        getMethodValue(this.classType, this.classObject, \"addDrink\", new Object[]{cloth2},getType(\"Drink\"));\r\n        getMethodValue(this.classType, this.classObject, \"buyDrink\", new Object[]{cloth3},getType(\"Drink\"));\r\n        size \u003d clothList.size();\r\n        Assertions.assertEquals(2,size);\r\n\r\n        //    String fieldNameMessage \u003d String.format(METHOD_INCORRECT_RETURN_VALUE, this.classObject.getSimpleName(), \"methodName\", actualFieldName, expectedFieldName);\r\n        // Create messages for all fields if assert fail\r\n\r\n        //   Assertions.assertEquals(fieldNameMessage, expectedFieldName, actualFieldName);\r\n        // Test all methods\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n\r\n                method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodException(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodExceptionWithMessageTest(String expectedExceptionName, String expectedExceptionMessage, Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                String testMessage \u003d String.format(METHOD_INCORRECT_EXCEPTION_MESSAGE,\r\n                        clazz.getSimpleName(),\r\n                        methodName,\r\n                        expectedExceptionName,\r\n                        expectedExceptionMessage,\r\n                        e.getTargetException().getClass().getSimpleName(),\r\n                        e.getTargetException().getMessage());\r\n\r\n                Assertions.assertEquals(expectedExceptionMessage, e.getTargetException().getMessage(), testMessage);\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 12
      },
      {
        "Id": 306125,
        "Input": "import org.junit.jupiter.api.Assertions;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport vendingSystem.Drink;\r\nimport vendingSystem.VendingMachine;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class T13ValidateReportMethod {\r\n    private static final String METHOD_INCORRECT_RETURN_VALUE \u003d \"Method \u0027%s.%s\u0027 returns invalid data (expected res: \u0027%s\u0027; actual - \u0027%s\u0027)!\";\r\n    private static final String METHOD_INCORRECT_EXCEPTION_MESSAGE \u003d \"Method \u0027%s.%s\u0027 throws invalid ex (expected: \u0027%s - %s\u0027; actual - \u0027%s - %s\u0027)!\";\r\n\r\n\r\n    private Class classObject;\r\n    private Object classType;\r\n\r\n    @BeforeEach\r\n    public void beforeMethod() {\r\n        Class controllerClass \u003d getType(\"VendingMachine\");\r\n\r\n        Object controller \u003d createObjectInstance(controllerClass, new Object[]{8});\r\n\r\n        this.classObject \u003d controllerClass;\r\n        this.classType \u003d controller;\r\n    }\r\n\r\n    @Test\r\n    public void validateReportMethod() {\r\n        Object[] empArguments \u003d new Object[]{\"Alco\", new BigDecimal(\"12\"), 121};\r\n        Class empClazz \u003d getType(\"Drink\");\r\n        Drink empObject \u003d (Drink) createObjectInstance(empClazz, empArguments);\r\n\r\n        Object[] empArguments2 \u003d new Object[]{\"Hol\", new BigDecimal(\"13\"), 113};\r\n        Drink empObject2 \u003d (Drink) createObjectInstance(empClazz, empArguments2);\r\n\r\n        try {\r\n            Field field \u003d VendingMachine.class.getDeclaredField(\"drinks\");\r\n            field.setAccessible(true);\r\n            List\u003cDrink\u003e list \u003d (List\u003cDrink\u003e) field.get(this.classType);\r\n            list.add(empObject);\r\n            list.add(empObject2);\r\n        } catch (NoSuchFieldException | IllegalAccessException nsfe) {\r\n            nsfe.printStackTrace();\r\n        }\r\n\r\n        Object actualFieldName \u003d getMethodValue(this.classType, this.classObject, \"report\", new Object[]{});\r\n        // Get all method return values\r\n\r\n        Object expectedFieldName \u003d \"Drinks available:\\n\"+\r\n                \"Name: Alco, Price: $12, Volume: 121 ml\\n\" +\r\n                \"Name: Hol, Price: $13, Volume: 113 ml\";\r\n\r\n        String fieldNameMessage \u003d String.format(METHOD_INCORRECT_RETURN_VALUE, this.classObject.getSimpleName(), \"report\", actualFieldName, expectedFieldName);\r\n        // Create messages for all fields if assert fail\r\n\r\n        Assertions.assertEquals(expectedFieldName, actualFieldName.toString().trim(), fieldNameMessage);\r\n        // Test all methods\r\n    }\r\n\r\n    private Object getMethodValue(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodException(Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object throwMethodExceptionWithMessageTest(String expectedExceptionName, String expectedExceptionMessage, Object object, Class clazz, String methodName, Object[] methodArgs, Class... parameterTypes) throws Throwable {\r\n        Method method \u003d getMethod(clazz, methodName, parameterTypes);\r\n\r\n        Object methodValue \u003d null;\r\n        if (method !\u003d null) {\r\n            try {\r\n                methodValue \u003d method.invoke(object, methodArgs);\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n                String testMessage \u003d String.format(METHOD_INCORRECT_EXCEPTION_MESSAGE,\r\n                        clazz.getSimpleName(),\r\n                        methodName,\r\n                        expectedExceptionName,\r\n                        expectedExceptionMessage,\r\n                        e.getTargetException().getClass().getSimpleName(),\r\n                        e.getTargetException().getMessage());\r\n\r\n                Assertions.assertEquals(expectedExceptionMessage, e.getTargetException().getMessage(), testMessage);\r\n                throw e.getTargetException();\r\n            }\r\n        }\r\n\r\n        return methodValue;\r\n    }\r\n\r\n    private Object createObjectInstance(Class clazz, Object[] arguments) {\r\n        Class[] argumentTypes \u003d null;\r\n\r\n        if (arguments !\u003d null) {\r\n            argumentTypes \u003d Arrays.stream(arguments).map(Object::getClass).toArray(Class[]::new);\r\n        }\r\n\r\n        Constructor ctor \u003d null;\r\n        try {\r\n            ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            mapIntegerToInt(argumentTypes);\r\n\r\n            try {\r\n                ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n            } catch (NoSuchMethodException ex) {\r\n                try {\r\n                    argumentTypes \u003d Arrays.stream(arguments).map(a -\u003e a.getClass().getInterfaces()[0]).toArray(Class[]::new);\r\n                    ctor \u003d clazz.getDeclaredConstructor(argumentTypes);\r\n                } catch (NoSuchMethodException exc) {\r\n                }\r\n            }\r\n        }\r\n\r\n        Object obj \u003d null;\r\n\r\n        if (ctor !\u003d null) {\r\n            try {\r\n                obj \u003d ctor.newInstance(arguments);\r\n            } catch (InstantiationException e) {\r\n                e.printStackTrace();\r\n            } catch (IllegalAccessException e) {\r\n            } catch (InvocationTargetException e) {\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    private void mapIntegerToInt(Class[] types) {\r\n        for (int i \u003d 0; i \u003c types.length; i++) {\r\n            if (types[i].getSimpleName().equals(Integer.class.getSimpleName())) {\r\n                types[i] \u003d int.class;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static Class getType(String name) {\r\n        Class clazz \u003d Classes.allClasses.get(name);\r\n\r\n        return clazz;\r\n    }\r\n\r\n    private Method getMethod(Class clazz, String expectedName, Class... parameterTypes) {\r\n        Method method \u003d null;\r\n\r\n        try {\r\n            method \u003d clazz.getMethod(expectedName, parameterTypes);\r\n        } catch (NoSuchMethodException e) {\r\n        }\r\n\r\n        return method;\r\n    }\r\n}",
        "Output": "Test Passed!",
        "IsTrialTest": false,
        "OrderBy": 13
      }
    ],
    "TaskSkeleton": null,
    "TaskSkeletonAsString": null
  },
  "ExecutionOptions": {
    "KeepDetails": true,
    "EscapeTests": false,
    "EscapeLineEndings": true
  },
  "WithExceptionStackTrace": true
}